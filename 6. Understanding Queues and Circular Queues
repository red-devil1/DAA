#             Experiment No.â€”6 : Understanding Queues and Circular Queues

# a. Develop linear and circular queues to simulate task scheduling.
b. Perform enqueue and dequeue with wrap-around logic.
c. Discuss memory utilization in linear vs circular queues.

#include <stdio.h>
#include <stdlib.h>
#define MAX 5 // Queue size
// ----------- Job Structure -----------
typedef struct {
int jobID;
int executionTime;
} Job;
// ----------- Linear Queue Structure -----------
typedef struct {
Job jobs[MAX];
int front, rear;
} LinearQueue;
// ----------- Circular Queue Structure -----------
typedef struct {
Job jobs[MAX];
int front, rear, count;
} CircularQueue;
// ----------- Linear Queue Functions -----------
void initLinearQueue(LinearQueue *q) {
q->front = q->rear = -1;
}
int isLinearEmpty(LinearQueue *q) {
return q->front == -1 || q->front > q->rear;
}
int isLinearFull(LinearQueue *q) {
return q->rear == MAX - 1;
}
void linearEnqueue(LinearQueue *q, Job job) {
if (isLinearFull(q)) {
printf("Linear Queue Overflow\n");
return;
}
if (q->front == -1) q->front = 0;
q->rear++;
q->jobs[q->rear] = job;
printf("Enqueued Job%d (Time=%d) to Linear Queue\n", job.jobID,
job.executionTime);
}
Job linearDequeue(LinearQueue *q) {
Job emptyJob = {-1, -1};
if (isLinearEmpty(q)) {
printf("Linear Queue Underflow\n");
return emptyJob;
}
Job job = q->jobs[q->front++];
printf("Dequeued Job%d (Time=%d) from Linear Queue\n", job.jobID,
job.executionTime);
return job;
}
// ----------- Circular Queue Functions -----------
void initCircularQueue(CircularQueue *cq) {
cq->front = cq->rear = cq->count = 0;
}
int isCircularEmpty(CircularQueue *cq) {
return cq->count == 0;
}
int isCircularFull(CircularQueue *cq) {
return cq->count == MAX;
}
void circularEnqueue(CircularQueue *cq, Job job) {
if (isCircularFull(cq)) {
printf("Circular Queue Overflow\n");
return;
}
cq->jobs[cq->rear] = job;
cq->rear = (cq->rear + 1) % MAX;
cq->count++;
printf("Enqueued Job%d (Time=%d) to Circular Queue\n", job.jobID,
job.executionTime);
}
Job circularDequeue(CircularQueue *cq) {
Job emptyJob = {-1, -1};
if (isCircularEmpty(cq)) {
printf("Circular Queue Underflow\n");
return emptyJob;
}
Job job = cq->jobs[cq->front];
cq->front = (cq->front + 1) % MAX;
cq->count--;
printf("Dequeued Job%d (Time=%d) from Circular Queue\n", job.jobID,
job.executionTime);
return job;
}
// ----------- Memory Utilization Discussion -----------
void memoryDiscussion() {
printf("\n--- Memory Utilization Discussion ---\n");
printf("Linear Queue:\n");
printf("- Once rear reaches end, free slots at the front cannot be reused.\n");
printf("- Causes memory wastage when many dequeues are done.\n");
printf("Circular Queue:\n");
printf("- Uses wrap-around logic to reuse freed slots.\n");
printf("- Better memory utilization and suitable for job/task scheduling.\n");
}
// ----------- Main Function (Simulation) -----------
int main() {
LinearQueue lq;
CircularQueue cq;
initLinearQueue(&lq);
initCircularQueue(&cq);
// Create sample jobs
Job j1 = {1, 200};
Job j2 = {2, 500};
Job j3 = {3, 300};
Job j4 = {4, 400};
printf("\n--- Linear Queue Simulation ---\n");
linearEnqueue(&lq, j1);
linearEnqueue(&lq, j2);
linearEnqueue(&lq, j3);
linearDequeue(&lq);
linearEnqueue(&lq, j4);
linearEnqueue(&lq, j3); // Overflow when full
printf("\n--- Circular Queue Simulation ---\n");
circularEnqueue(&cq, j1);
circularEnqueue(&cq, j2);
circularEnqueue(&cq, j3);
circularEnqueue(&cq, j4);
circularDequeue(&cq);
circularDequeue(&cq);
circularEnqueue(&cq, j1); // Wrap-around logic
circularEnqueue(&cq, j2); // Still fits
memoryDiscussion();
return 0;
}
