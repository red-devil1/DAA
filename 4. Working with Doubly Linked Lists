#             Experiment No.â€”4 : Working with Doubly Linked Lists

# a. Create a doubly linked list with forward and backward traversal.
b. Implement insertion/deletion at head, tail, and specific positions.
c. Use in scenarios like browser history or undo-redo features.

// Create a new node
struct Node* createNode(char value[]) {
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
strcpy(newNode->data, value);
newNode->next = NULL;
newNode->prev = NULL;
return newNode;
}
// Insert at head
void insertAtHead(struct Node** head, char value[]) {
struct Node* newNode = createNode(value);
if (*head == NULL) {
*head = newNode;
return;
}
newNode->next = *head;
(*head)->prev = newNode;
*head = newNode;
}
// Insert at tail
void insertAtTail(struct Node** head, char value[]) {
struct Node* newNode = createNode(value);
if (*head == NULL) {
*head = newNode;
return;
}
struct Node* temp = *head;
while (temp->next != NULL) {
temp = temp->next;
}
temp->next = newNode;
newNode->prev = temp;
}
// Insert at specific position (1-based index)
void insertAtPosition(struct Node** head, char value[], int pos) {
if (pos <= 1 || *head == NULL) {
insertAtHead(head, value);
return;
}
struct Node* temp = *head;
for (int i = 1; temp->next != NULL && i < pos - 1; i++) {
temp = temp->next;
}
struct Node* newNode = createNode(value);
newNode->next = temp->next;
if (temp->next != NULL) {
temp->next->prev = newNode;
}
temp->next = newNode;
newNode->prev = temp;
}
// Delete at head
void deleteAtHead(struct Node** head) {
if (*head == NULL) return;
struct Node* temp = *head;
*head = (*head)->next;
if (*head != NULL) (*head)->prev = NULL;
free(temp);
}
// Delete at tail
void deleteAtTail(struct Node** head) {
if (*head == NULL) return;
struct Node* temp = *head;
while (temp->next != NULL) temp = temp->next;
if (temp->prev != NULL) temp->prev->next = NULL;
else *head = NULL; // only one node
free(temp);
}
// Delete at specific position
void deleteAtPosition(struct Node** head, int pos) {
if (*head == NULL) return;
if (pos == 1) {
deleteAtHead(head);
return;
}
struct Node* temp = *head;
for (int i = 1; temp != NULL && i < pos; i++) {
temp = temp->next;
}
if (temp == NULL) return;
if (temp->prev != NULL) temp->prev->next = temp->next;
if (temp->next != NULL) temp->next->prev = temp->prev;
free(temp);
}
// Forward traversal
void displayForward(struct Node* head) {
struct Node* temp = head;
while (temp != NULL) {
printf("%s <-> ", temp->data);
temp = temp->next;
}
printf("NULL\n");
}
// Backward traversal
void displayBackward(struct Node* head) {
if (head == NULL) return;
struct Node* temp = head;
while (temp->next != NULL) temp = temp->next; // move to last
while (temp != NULL) {
printf("%s <-> ", temp->data);
temp = temp->prev;
}
printf("NULL\n");
}
// Example usage: Browser history (back and forward)
void browserHistoryDemo() {
struct Node* history = NULL;
insertAtTail(&history, "Google.com");
insertAtTail(&history, "YouTube.com");
insertAtTail(&history, "Instagram.com");
insertAtTail(&history, "ChatGPT.com");
printf("\nBrowser History Forward:\n");
displayForward(history);
printf("Browser History Backward:\n");
displayBackward(history);
}
int main() {
struct Node* head = NULL;
insertAtHead(&head, "Saumya");
insertAtTail(&head, "Sanchita");
insertAtTail(&head, "Aarti");
insertAtPosition(&head, "Riya", 2);
printf("Forward Traversal: ");
displayForward(head);
printf("Backward Traversal: ");
displayBackward(head);
deleteAtPosition(&head, 2);
printf("\nAfter Deletion at Position 2:\n");
displayForward(head);
// Browser history demo
browserHistoryDemo();
return 0;
}
