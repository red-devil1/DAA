#             Experiment No.â€”8 : Balanced Trees & Priority Queues

# a. Insert values and observe AVL tree rebalancing.
b. Construct min-heaps or max-heaps and simulate priority queues.
c. Use priority queues to manage task priorities (e.g., patient triage, job scheduling).

#include <stdio.h>
#include <stdlib.h>
// ---------- AVL TREE ----------
typedef struct Node {
int key, height;
struct Node *left, *right;
} Node;
int max(int a, int b){ return a>b?a:b; }
int height(Node* n){ return n? n->height:0; }
Node* newNode(int key){
Node* node = (Node*)malloc(sizeof(Node));
node->key = key; node->left = node->right = NULL; node->height = 1;
return node;
}
Node* rotateRight(Node* y){
Node* x=y->left; Node* T=x->right;
x->right=y; y->left=T;
y->height=1+max(height(y->left),height(y->right));
x->height=1+max(height(x->left),height(x->right));
return x;
}
Node* rotateLeft(Node* x){
Node* y=x->right; Node* T=y->left;
y->left=x; x->right=T;
x->height=1+max(height(x->left),height(x->right));
y->height=1+max(height(y->left),height(y->right));
return y;
}
int getBalance(Node* n){ return n? height(n->left)-height(n->right):0; }
Node* insert(Node* root, int key){
if(!root) return newNode(key);
if(key<root->key) root->left=insert(root->left,key);
else if(key>root->key) root->right=insert(root->right,key);
else return root;
root->height=1+max(height(root->left),height(root->right));
int bal=getBalance(root);
if(bal>1 && key<root->left->key) return rotateRight(root);
if(bal<-1 && key>root->right->key) return rotateLeft(root);
if(bal>1 && key>root->left->key){ root->left=rotateLeft(root->left); return
rotateRight(root);}
if(bal<-1 && key<root->right->key){ root->right=rotateRight(root->right); return
rotateLeft(root);}
return root;
}
void preOrder(Node* root){
if(root){ printf("%d ",root->key); preOrder(root->left); preOrder(root->right); }
}
// ---------- MAX HEAP (Priority Queue) ----------
#define MAX 20
int heap[MAX], size=0;
void insertHeap(int val){
heap[++size]=val;
int i=size;
while(i>1 && heap[i/2]<heap[i]){ int t=heap[i]; heap[i]=heap[i/2]; heap[i/2]=t; i/=2;
}
}
int extractMax(){
if(size==0) return -1;
int max=heap[1]; heap[1]=heap[size--];
int i=1;
while(i*2<=size){
int big=i;
if(heap[i*2]>heap[big]) big=i*2;
if(i*2+1<=size && heap[i*2+1]>heap[big]) big=i*2+1;
if(big==i) break;
int t=heap[i]; heap[i]=heap[big]; heap[big]=t;
i=big;
}
return max;
}
// ---------- MAIN----------
int main(){
Node* root=NULL;
int vals[]={10,20,30,40,50,25};
printf("\nAVL Tree Insertions (PreOrder after each):\n");
for(int i=0;i<6;i++){ root=insert(root,vals[i]); preOrder(root); printf("\n"); }
printf("\nPriority Queue (Max-Heap):\n");
int tasks[]={30,10,50,40,20};
for(int i=0;i<5;i++) insertHeap(tasks[i]);
printf("Serving tasks by priority: ");
while(size>0) printf("%d ",extractMax());
printf("\n");
return 0;
}
