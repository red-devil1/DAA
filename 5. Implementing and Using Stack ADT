#             Experiment No.â€”5 : Implementing and Using Stack ADT

# a. Implement push, pop, peek using arrays or linked lists.
b. Solve problems like delimiter matching or undo mechanism.
c. Convert expressions from prefix to postfix and evaluate them.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#define SIZE 100
// ---------- Stack (Array based) ----------
typedef struct {
int top;
char arr[SIZE][SIZE]; // for storing strings (used in conversion too)
} Stack;
void init(Stack *s) { s->top = -1; }
int isEmpty(Stack *s) { return s->top == -1; }
int isFull(Stack *s) { return s->top == SIZE - 1; }
void push(Stack *s, char *val) {
if (isFull(s)) {
printf("Stack Overflow\n");
} else {
strcpy(s->arr[++(s->top)], val);
}
}
char* pop(Stack *s) {
if (isEmpty(s)) {
printf("Stack Underflow\n");
return "";
} else {
return s->arr[(s->top)--];
}
}
char* peek(Stack *s) {
if (isEmpty(s)) return "";
return s->arr[s->top];
}
// ---------- a) Delimiter Matching ----------
int isMatching(char open, char close) {
return (open == '(' && close == ')') ||
(open == '{' && close == '}') ||
(open == '[' && close == ']');
}
int checkBalanced(char *expr) {
Stack s; init(&s);
char temp[2];
for (int i = 0; expr[i]; i++) {
if (expr[i] == '(' || expr[i] == '{' || expr[i] == '[') {
temp[0] = expr[i]; temp[1] = '\0';
push(&s, temp);
} else if (expr[i] == ')' || expr[i] == '}' || expr[i] == ']') {
if (isEmpty(&s)) return 0;
char *op = pop(&s);
if (!isMatching(op[0], expr[i])) return 0;
}
}
return isEmpty(&s);
}
// ---------- b) Prefix to Postfix ----------
int isOperator(char c) {
return (c=='+' || c=='-' || c=='*' || c=='/');
}
void prefixToPostfix(char *prefix, char *postfix) {
Stack s; init(&s);
char temp[2];
for (int i = strlen(prefix)-1; i >= 0; i--) {
if (isalnum(prefix[i])) {
temp[0] = prefix[i]; temp[1] = '\0';
push(&s, temp);
} else if (isOperator(prefix[i])) {
char op1[SIZE], op2[SIZE], expr[SIZE];
strcpy(op1, pop(&s));
strcpy(op2, pop(&s));
sprintf(expr, "%s%s%c", op1, op2, prefix[i]);
push(&s, expr);
}
}
strcpy(postfix, pop(&s));
}
// ---------- c) Prefix Evaluation ----------
int evalPrefix(char *expr) {
int stack[SIZE]; int top = -1;
for (int i = strlen(expr)-1; i >= 0; i--) {
if (isdigit(expr[i])) {
stack[++top] = expr[i] - '0';
} else if (isOperator(expr[i])) {
int a = stack[top--];
int b = stack[top--];
switch(expr[i]) {
case '+': stack[++top] = a + b; break;
case '-': stack[++top] = a - b; break;
case '*': stack[++top] = a * b; break;
case '/': stack[++top] = a / b; break;
}
}
}
return stack[top];
}
// ---------- MAIN ----------
int main() {
// Stack operations
Stack s; init(&s);
printf("Push A, B, C into stack:\n");
push(&s, "A");
push(&s, "B");
push(&s, "C");
printf("Top element (peek): %s\n", peek(&s));
printf("Pop: %s\n", pop(&s));
printf("Top after pop: %s\n\n", peek(&s));
// Delimiter matching
char expr[] = "{(a+b)*(c-d)}";
printf("Delimiter Matching for: %s\n", expr);
printf("%s\n\n", checkBalanced(expr) ? "Balanced" : "Not Balanced");
// Prefix to Postfix
char prefix[] = "*+AB-CD";
char postfix[SIZE];
prefixToPostfix(prefix, postfix);
printf("Prefix Expression: %s\n", prefix);
printf("Converted to Postfix: %s\n\n", postfix);
// Prefix Evaluation
char evalExpr[] = "+*745+20"; // ((7*4)+5)+(2+0) = 25
printf("Evaluating Prefix Expression: %s\n", evalExpr);
printf("Result: %d\n", evalPrefix(evalExpr));
return 0;
}
